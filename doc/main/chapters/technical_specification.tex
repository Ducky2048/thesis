\chapter{Technical Specification}
\section{REST API}
Endpoints:

\begin{tabular}{|l|l|l|}
	\hline
	Endpoint & Method & Description \\ \hline
	/api/v1/hashes & POST & send hashes to generate nonce \\ \hline
	/api/v1/login & POST & get oidc providers \\ \hline
	/api/v1/sign & POST & sign hashes \\ \hline
	/api/v1/signatures & GET & retrieve list of all signatures for current session \\ \hline
	/api/v1/signatures/:hash & GET & retrieve signature \\ \hline
\end{tabular}

\subsection{hashes}
Input:

\begin{tabular}{|l|l|l|l|}
	\hline
	Parameter & Presence & Type & Description \\ \hline
	hashes & MANDATORY & list(string) & Hashes of the documents to be signed \\ \hline
\end{tabular}

Output:

\begin{tabular}{|l|l|l|l|}
	\hline
	Parameter & Presence & Type & Description \\ \hline
	nonce & MANDATORY & string & Nonce to use for generating to OIDC nonce in the token \\ \hline
\end{tabular}

Sample Request:
\begin{lstlisting}[caption={hashes request}, captionpos=b, language=JavaScript, label={lst:hashesrequest}]
POST /api/v1/hashes HTTP/1.1
Host: service.example.org
Content-Type: application/json

{
  "hashes": [
  "e8a96e6203b9c0df058ba862abc63d9c520157faef6d5d54e54e526b0a85b2be",
  "0b9a7fd3e612061a7fe6d834e102a143170f33d0e8c5a8eb79416aa3eb53c0d6"
  ]
}
\end{lstlisting}

Sample Response:
\begin{lstlisting}[caption={hashes response}, captionpos=b, language=JavaScript, label={lst:hashesresponse}]
HTTP/1.1 201 Created
Content-Type: application/json

{
  "nonce": "test1234"
}
\end{lstlisting}

\subsection{login}
Input:

\begin{tabular}{|l|l|l|l|}
	\hline
	Parameter & Presence & Type & Description \\ \hline
	nonce & MANDATORY & string & Nonce to use for retrieving the OIDC token \\ \hline
\end{tabular}

Output:

\begin{tabular}{|l|l|l|l|}
	\hline
	Parameter & Presence & Type & Description \\ \hline
	providers & MANDATORY & dictionary[string]url & List of providers with the redirect url \\ \hline
\end{tabular}

Sample Request:
\begin{lstlisting}[caption={login request}, captionpos=b, language=JavaScript, label={lst:loginrequest}]
POST /api/v1/login HTTP/1.
Host: service.example.org
Content-Type: application/json

{
  "nonce": "6cd7ef99e5e79d68d681e5d097b7f805381c4d013152fa3f26d06bd728ae49fa"
}
\end{lstlisting}

Sample Response:

\begin{lstlisting}[caption={login response}, captionpos=b, language=JavaScript, label={lst:loginresponse}]
HTTP/1.1 200 OK
Content-Type: application/json

{
  "providers": {
    "SwissID": "https://...&nonce=6cd7ef99e5e79d68d681e5d097b7f805381c4d013152fa3f26d06bd728ae49fa",
    "Google": "https://...&nonce=6cd7ef99e5e79d68d681e5d097b7f805381c4d013152fa3f26d06bd728ae49fa"
  }
}
\end{lstlisting}

\subsection{sign}
Input:

\begin{tabular}{|l|l|l|l|}
	\hline
	Parameter & Presence & Type & Description \\ \hline
	idtoken & MANDATORY & string & OIDC ID token \\ \hline
	nonce & MANDATORY & string & Nonce to use for generating to OIDC nonce in the token \\ \hline
	hashes & MANDATORY & list(string) & Hashes of the documents to be signed \\ \hline
\end{tabular}

Output:

\begin{tabular}{|l|l|l|l|}
	\hline
	Parameter & Presence & Type & Description \\ \hline
	result & MANDATORY & bool & Status of the signing (true = success, false = failure) \\ \hline
\end{tabular}

Sample Request:
\begin{lstlisting}[caption={sign request}, captionpos=b, language=JavaScript, label={lst:signrequest}]
POST /api/v1/sign HTTP/1.
Host: service.example.org
Content-Type: application/json

{
  "idtoken": {...},
  "nonce": "test1234",
  "hashes": [
    "e8a96e6203b9c0df058ba862abc63d9c520157faef6d5d54e54e526b0a85b2be",
    "0b9a7fd3e612061a7fe6d834e102a143170f33d0e8c5a8eb79416aa3eb53c0d6"
  ]
}
\end{lstlisting}

Sample Response:

\begin{lstlisting}[caption={sign response}, captionpos=b, language=JavaScript, label={lst:signresponse}]
HTTP/1.1 201 Created
Content-Type: application/json

{
  "result": true
}
\end{lstlisting}

\subsection{signatures}
Output:

\begin{tabular}{|l|l|l|l|}
	\hline
	Parameter & Presence & Type & Description \\ \hline
	hashes & MANDATORY & list(string) & hashes that were signed \\ \hline
\end{tabular}

Sample Request:

\begin{lstlisting}[caption={signatures request}, captionpos=b, language=JavaScript, label={lst:signaturesrequest}]
GET /api/v1/signatures HTTP/1.
Host: service.example.org
Content-Type: application/json
\end{lstlisting}

Sample Response:

\begin{lstlisting}[caption={signatures response}, captionpos=b, language=JavaScript, label={lst:signaturesresponse}]
HTTP/1.1 200 OK
Content-Type: application/json

{
  "hashes": [
    "e8a96e6203b9c0df058ba862abc63d9c520157faef6d5d54e54e526b0a85b2be",
    "0b9a7fd3e612061a7fe6d834e102a143170f33d0e8c5a8eb79416aa3eb53c0d6"
  ]
}
\end{lstlisting}

\subsection{signatures/:hash}
Input:

\begin{tabular}{|l|l|l|l|}
	\hline
	Parameter & Presence & Type & Description \\ \hline
	hash & MANDATORY & string & hash that was signed \\ \hline
\end{tabular}

Output:

\begin{tabular}{|l|l|l|l|}
	\hline
	Parameter & Presence & Type & Description \\ \hline
	signature & MANDATORY & binary & base64 encoded signature for the requested hash \\ \hline
\end{tabular}

Sample Request:

\begin{lstlisting}[caption={signature request}, captionpos=b, language=JavaScript, label={lst:signaturerequest}]
GET /api/v1/signatures/e8a96e6203b9c0df058ba862abc63d9c520157faef6d5d54e54e526b0a85b2be HTTP/1.
Host: service.example.org
Content-Type: application/json
\end{lstlisting}

Sample Response:

\begin{lstlisting}[caption={signature response}, captionpos=b, language=JavaScript, label={lst:signatureresponse}]
HTTP/1.1 200 OK
Content-Type: application/json

{
  "signature": "IyMjIFJFU1QgQVBJIFNwZWNpZmljYXRpb24gU2NyYXRjaHBhZAoKIyMjIyBQcmUtQXV0aCBlbmRw...b2ludCAKIyMjIyMgRW5kcG9pbnQKYGBgUE9TVCAvYXBpL3YxL3NpZ25gYGAK"
}
\end{lstlisting}

\section{Signature File Format}
TODO
\subsection{Long-Term Validation}
\gls{LTV} allows for the validation of signatures long after the document was signed~\cite{etsipades}.

We need \gls{LTV} for two main reasons:
\begin{enumerate}
    \item Imagine if the \gls{CA} were revoked that was used for the signatures: all signatures created using the same \gls{CA} would become invalid instantly, making countless documents, constracts and the like unverifiable.
    \item Extending the validity of the signature beyond the lifetime of the \gls{CA} used to sign it, for signatures that need to remain valid and verifiable for a very long time.
\end{enumerate}
In order for us to achieve this, all required elements for signature validation must be embedded into the signature file.
Without the addition of these elements, a signature can only be validated for a limited time.
This limitation occurs because the \gls{CA}s eventually expire, or get revoked.
Once the \gls{CA} certificate has expired, the issuing authority is no longer responsible for providing the revocation status information on that certificate.
Without the confirmed revocation status information on the signing keys, the signature cannot be validated.

To overcome this limitation, the following information has to be embedded into the signature:
\begin{enumerate}
    \item A timestamp on the signature
    \item The signing certificate
    \item The certificates used and their revocation status (\gls{OCSP} and \gls{CRL})
    \item An archive timestamp of the previous content
\end{enumerate}

The archive timestamp establishes the date in which the information collected was issued.
Provided the archive timestamp is valid,
we can be sure that the revocation information was issued at that time,
and check the validity of the signing certificate and the \gls{CA} certificate chain.
Thus we can be certain that it was not revoked at the point in time the document was signed.
This allows us to extend the validity of the signature past the expiration time of the \gls{CA}.

However, this does not extend the validity of the signature indefinitely,
it merely extends the expiration until the expiration time of the timestamping authority's certificate.

For many cases this may be enough, but it doesn't quite allow for long-time archival yet.
When the timestamping certificates' expiration is impending,
the signature expiration time has to be extended by adding another timestamp signed by a \gls{CA} not yet close to expiration.
This re-stamping has to be repeated periodically in order to keep the signature valid and verifiable.
This allows for near-indefinite archival.

